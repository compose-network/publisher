#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
STATUS_TIMEOUT=${STATUS_TIMEOUT:-2}
RPC_RETRIES=${RPC_RETRIES:-240}
RPC_DELAY=${RPC_DELAY:-1}
PUBLISHER_HEALTH_TIMEOUT=${PUBLISHER_HEALTH_TIMEOUT:-2}
PUBLISHER_RETRIES=${PUBLISHER_RETRIES:-240}
BLOCKSCOUT_HEALTH_TIMEOUT=${BLOCKSCOUT_HEALTH_TIMEOUT:-5}
BLOCKSCOUT_RETRIES=${BLOCKSCOUT_RETRIES:-240}
TABLE_DELIM=$'\x1f'
declare -A CONTRACTS=()

log() {
  printf '[local] %s\n' "$*"
}

err() {
  printf '[local] %s\n' "$*" >&2
}

usage() {
  cat <<'USAGE'
Usage: ./local <command> [options]

Commands:
  up                    Bootstrap (runs setup on first use) or start the stack.
  down                  Stop containers without removing volumes.
  status                Show container state, RPC endpoints, and health summaries.
  logs [target ...]     Stream logs for services (see Log Targets below).
  restart <target>      Restart services (target: op-geth | publisher | blockscout | all).
  deploy <target>       Rebuild images then restart (target: op-geth | publisher | blockscout | all).
  purge [--force]       Stop everything, remove volumes, and delete generated state.
  help                  Show this message.

Log Targets:
  all                   All services from both rollups + shared publisher
  publisher             Shared publisher service only
  a                     All services for rollup A
  b                     All services for rollup B
  a/<service>           Specific service for rollup A only
  b/<service>           Specific service for rollup B only
  <service>             Service from both rollups (consistency with deploy/restart)

  Valid services: op-geth, op-node, op-batcher, op-proposer, blockscout

  Examples:
    ./local logs op-geth           # op-geth from both rollups
    ./local logs a/op-geth         # Only op-geth from rollup A
    ./local logs blockscout        # All blockscout services (both rollups)
    ./local logs a                 # All rollup A services
    ./local logs --tail 50 op-node # Last 50 lines from both op-nodes

Environment:
  STATUS_TIMEOUT (default 2s)   RPC and health check curl timeout.
  RPC_RETRIES (default 240)     Attempts when waiting for RPC readiness (4 min with 1s delay).
  RPC_DELAY (default 1s)        Delay between RPC readiness checks.
USAGE
}

populate_mailbox_env() {
  if [[ -n "${ROLLUP_A_MAILBOX_ADDR:-}" && -n "${ROLLUP_B_MAILBOX_ADDR:-}" ]]; then
    return
  fi

  local contracts_json="${ROOT_DIR}/networks/rollup-a/contracts.json"
  if [[ ! -f "$contracts_json" ]]; then
    return
  fi

  local detected
  detected=$(CONTRACTS_JSON="$contracts_json" python3 - <<'PY'
import json
import os

path = os.environ.get("CONTRACTS_JSON")
if not path:
    raise SystemExit
try:
    with open(path) as fh:
        data = json.load(fh)
except Exception:
    raise SystemExit

addresses = {}
if isinstance(data, dict):
    addresses = data.get("addresses") or {}
    if not isinstance(addresses, dict):
        parent = data.get("parent") or {}
        if isinstance(parent, dict):
            addresses = parent.get("addresses") or {}

mailbox = addresses.get("Mailbox")
if mailbox:
    print(mailbox)
PY
  )

  if [[ -z "$detected" ]]; then
    return
  fi

  if [[ -z "${ROLLUP_A_MAILBOX_ADDR:-}" ]]; then
    export ROLLUP_A_MAILBOX_ADDR="$detected"
  fi
  if [[ -z "${ROLLUP_B_MAILBOX_ADDR:-}" ]]; then
    export ROLLUP_B_MAILBOX_ADDR="$detected"
  fi
}

describe_source_path() {
  local label=$1
  local path=$2
  [[ -z $path ]] && return
  local resolved
  if resolved=$(cd "$path" 2>/dev/null && pwd); then
    path=$resolved
  elif [[ $path != /* ]]; then
    path="$ROOT_DIR/$path"
  fi
  if [[ -d $path ]]; then
    log "${label} source: $path"
  else
    log "${label} source: $path (missing)"
  fi
}

log_source_contexts() {
  local target=${1:-all}
  local op_geth_src="${OP_GETH_PATH:-$ROOT_DIR/services/op-geth}"
  local rsp_src="${ROLLUP_SHARED_PUBLISHER_PATH:-$ROOT_DIR/services/rollup-shared-publisher}"
  case "$target" in
    op-geth)
      describe_source_path "op-geth" "$op_geth_src"
      ;;
    publisher)
      describe_source_path "rollup-shared-publisher" "$rsp_src"
      ;;
    all)
      describe_source_path "op-geth" "$op_geth_src"
      describe_source_path "rollup-shared-publisher" "$rsp_src"
      ;;
    blockscout)
      ;;
    *)
      describe_source_path "op-geth" "$op_geth_src"
      describe_source_path "rollup-shared-publisher" "$rsp_src"
      ;;
  esac
  if [[ -n ${SEQUENCER_ADDRESS:-} ]]; then
    log "sequencer address: ${SEQUENCER_ADDRESS}"
  fi
}

load_env() {
  local required=${1:-1}
  if [[ -f "${ROOT_DIR}/.env" ]]; then
    set -a
    # shellcheck source=/dev/null
    source "${ROOT_DIR}/.env"
    set +a
  elif [[ $required -eq 1 ]]; then
    err "Missing .env; copy .env.example and fill in the required values."
    exit 1
  fi

  if [[ -f "${ROOT_DIR}/toolkit.env" ]]; then
    set -a
    # shellcheck source=/dev/null
    source "${ROOT_DIR}/toolkit.env"
    set +a
  fi

  export ROLLUP_A_CHAIN_ID=${ROLLUP_A_CHAIN_ID:-77771}
  export ROLLUP_B_CHAIN_ID=${ROLLUP_B_CHAIN_ID:-77772}

  local default_seq_priv=0x1111111111111111111111111111111111111111111111111111111111111111
  local default_seq_addr=0x19e7e376e7c213b7e7e7e46cc70a5dd086daff2a
  export SEQUENCER_PRIVATE_KEY=${SEQUENCER_PRIVATE_KEY:-$default_seq_priv}
  export SEQUENCER_ADDRESS=${SEQUENCER_ADDRESS:-$default_seq_addr}

  populate_mailbox_env
}

compose() {
  (cd "$ROOT_DIR" && docker compose "$@")
}

remove_path() {
  local rel=$1
  local target="$ROOT_DIR/$rel"
  [[ -e $target ]] || return 0
  if rm -rf "$target" 2>/dev/null; then
    return 0
  fi
  if docker run --rm -v "$ROOT_DIR:/workspace" alpine:3 sh -c "rm -rf \"/workspace/$rel\"" >/dev/null 2>&1; then
    return 0
  fi
  err "Unable to remove $rel (permission issues); delete manually"
  return 0
}

remove_generated_artifacts() {
  remove_path "state"
  remove_path "networks"
  remove_path ".cache/genesis-go"
  clean_contracts_generated
}

clean_contracts_generated() {
  local -a targets=()
  local gitignore="$ROOT_DIR/.gitignore"
  if [[ -f "$gitignore" ]]; then
    while IFS= read -r line; do
      [[ -z "$line" || "$line" =~ ^# ]] && continue
      if [[ "$line" == contracts/* ]]; then
        line="${line%/}"
        targets+=("$line")
      fi
    done <"$gitignore"
  fi

  if [[ ${#targets[@]} -eq 0 ]]; then
    targets=(
      "contracts/artifacts"
      "contracts/broadcast"
      "contracts/cache"
      "contracts/out"
      "contracts/lib"
    )
  fi

  for rel in "${targets[@]}"; do
    remove_path "$rel"
  done
}

is_bootstrapped() {
  [[ -f "$ROOT_DIR/networks/rollup-a/rollup.json" && -f "$ROOT_DIR/networks/rollup-b/rollup.json" ]]
}

running_services() {
  compose ps --status running --services 2>/dev/null || true
}

existing_services() {
  compose ps --all --services 2>/dev/null || true
}

repeat_char() {
  local char=$1
  local count=${2:-0}
  if (( count <= 0 )); then
    printf ''
    return
  fi
  local buf
  printf -v buf '%*s' "$count" ''
  printf '%s' "${buf// /$char}"
}

display_width() {
  python3 - "$1" <<'PY'
import sys
import unicodedata

text = sys.argv[1]
width = 0
for ch in text:
    if unicodedata.combining(ch):
        continue
    east = unicodedata.east_asian_width(ch)
    if east in ('F', 'W'):
        width += 2
    else:
        width += 1
print(width)
PY
}

build_title_line() {
  local title=$1
  local width=$2
  local display=" $title "
  local disp_len=${#display}
  if (( disp_len > width )); then
    display=${display:0:width}
    disp_len=${#display}
  fi
  local pad=$((width - disp_len))
  (( pad < 0 )) && pad=0
  local left=$((pad / 2))
  local right=$((pad - left))
  printf '+%s%s%s+' "$(repeat_char '=' "$left")" "$display" "$(repeat_char '=' "$right")"
}

normalize_status() {
  local raw=${1:-}
  [[ -z $raw ]] && { echo '-'; return; }
  raw=${raw%% (healthy)*}
  raw=${raw%% (health:*)}
  raw=${raw%% (starting)*}
  raw=$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]')
  raw=${raw//about /~}
  raw=${raw//less than a second/<1s}
  raw=${raw//seconds/s}
  raw=${raw//second/s}
  raw=${raw//minutes/m}
  raw=${raw//minute/1m}
  raw=${raw//hours/h}
  raw=${raw//hour/h}
  raw=${raw//days/d}
  raw=${raw//day/d}
  raw=${raw// ago/}
  raw=${raw//  / }
  raw=$(printf '%s\n' "$raw" | sed -E 's/([0-9]) m/\1m/g; s/([0-9]) h/\1h/g; s/([0-9]) d/\1d/g; s/([0-9]) s/\1s/g; s/ +/ /g')
  raw=${raw## }
  raw=${raw%% }
  [[ -z $raw ]] && raw='-'
  echo "$raw"
}

format_status_text() {
  local state=$1
  local status=$2
  local icon
  case $state in
    running) icon="✅" ;;
    restarting) icon="♻️" ;;
    exited|dead|removing) icon="❌" ;;
    paused) icon="⏸️" ;;
    *) icon="❔" ;;
  esac
  local normalized
  normalized=$(normalize_status "$status")
  if [[ $normalized == '-' || -z $normalized ]]; then
    if [[ -n $state && $state != 'running' ]]; then
      normalized=$state
    else
      normalized='unknown'
    fi
  fi
  printf '%s %s' "$icon" "$normalized"
}

render_panel() {
  local title=$1
  shift
  local rows=("$@")
  local delim=${TABLE_DELIM:-$'\x1f'}
  if ((${#rows[@]} == 0)); then
    local width=${#title}
    printf '%s\n' "$(build_title_line "$title" "$width")"
    printf '+%s+\n' "$(repeat_char '=' "$width")"
    return
  fi

  local -a widths
  local col_count=0
  local row
  for row in "${rows[@]}"; do
    IFS=$delim read -r -a cols <<< "$row"
    (( ${#cols[@]} > col_count )) && col_count=${#cols[@]}
    local i
    for ((i=0; i<${#cols[@]}; i++)); do
      local len
      len=$(display_width "${cols[i]}")
      if [[ -z ${widths[i]:-} || ${widths[i]} -lt $len ]]; then
        widths[i]=$len
      fi
    done
  done
  local i
  for ((i=0; i<col_count; i++)); do
    widths[i]=${widths[i]:-0}
  done

  local -a row_strings=()
  for row in "${rows[@]}"; do
    IFS=$delim read -r -a cols <<< "$row"
    local line='|'
    for ((i=0; i<col_count; i++)); do
      local val=${cols[i]:-}
      local pad
      local disp
      disp=$(display_width "$val")
      pad=$((widths[i] - disp))
      (( pad < 0 )) && pad=0
      line+=' '
      line+="$val"
      line+="$(repeat_char ' ' "$pad")"
      line+=' |'
    done
    row_strings+=("$line")
  done

  local max_display_width=0
  for row in "${row_strings[@]}"; do
    local disp
    disp=$(display_width "$row")
    if (( disp > max_display_width )); then
      max_display_width=$disp
    fi
  done

  local -a normalized_rows=()
  for row in "${row_strings[@]}"; do
    local disp
    disp=$(display_width "$row")
    local pad=$((max_display_width - disp))
    (( pad < 0 )) && pad=0
    normalized_rows+=("${row}$(repeat_char ' ' "$pad")")
  done

  local inner_width=$((max_display_width - 2))
  (( inner_width < 0 )) && inner_width=0
  printf '%s\n' "$(build_title_line "$title" "$inner_width")"
  for row in "${normalized_rows[@]}"; do
    printf '%s\n' "$row"
  done
  printf '+%s+\n' "$(repeat_char '=' "$inner_width")"
}

get_service_entry() {
  local svc=$1
  local default_state=$2
  local entry=${STATES[$svc]:-}
  if [[ -z $entry ]]; then
    printf '%s|\n' "$default_state"
  else
    printf '%s\n' "$entry"
  fi
}

format_service_status() {
  local svc=$1
  local default_state=$2
  local entry
  entry=$(get_service_entry "$svc" "$default_state")
  local state=${entry%%|*}
  local status=${entry#*|}
  format_status_text "$state" "$status"
}

load_contracts() {
  CONTRACTS=()
  local file="$ROOT_DIR/networks/rollup-a/contracts.json"
  if [[ ! -f $file ]]; then
    file="$ROOT_DIR/networks/rollup-b/contracts.json"
  fi
  [[ ! -f $file ]] && return
  while IFS= read -r line; do
    [[ -z $line ]] && continue
    local key=${line%%=*}
    local value=${line#*=}
    CONTRACTS["$key"]=$value
  done < <(python3 - "$file" <<'PY'
import json
import sys
path = sys.argv[1]
try:
    with open(path) as f:
        data = json.load(f)
except FileNotFoundError:
    sys.exit(0)
for key, value in data.get('addresses', {}).items():
    print(f"{key}={value}")
PY
  )
}

fetch_block_number() {
  local url=$1
  local payload='{"jsonrpc":"2.0","id":1,"method":"eth_blockNumber","params":[]}'
  local response
  response=$(curl --silent --show-error --fail --max-time "$STATUS_TIMEOUT" --connect-timeout "$STATUS_TIMEOUT" \
    --header 'Content-Type: application/json' --data "$payload" "$url" 2>/dev/null) || return 1
  local block
  block=$(python3 - "$response" 2>/dev/null <<'PY'
import json, sys
try:
    data = json.loads(sys.argv[1])
    result = data.get('result')
    if isinstance(result, str) and result.startswith('0x'):
        print(int(result, 16))
except Exception:
    pass
PY
)
  [[ -n ${block:-} ]] || return 1
  printf '%s\n' "$block"
}

wait_for_rpc() {
  local url=$1
  local label=$2
  local tries=$RPC_RETRIES
  local delay=$RPC_DELAY
  local block
  for ((i=1; i<=tries; i++)); do
    if block=$(fetch_block_number "$url"); then
      log "${label} ready at block ${block}"
      return 0
    fi
    sleep "$delay"
  done
  err "Timed out waiting for ${label} at ${url}"
  return 1
}

publisher_health() {
  local url=$1
  curl --silent --show-error --output /dev/null --write-out '%{http_code}' \
    --max-time "$PUBLISHER_HEALTH_TIMEOUT" --connect-timeout "$PUBLISHER_HEALTH_TIMEOUT" "$url" 2>/dev/null || true
}

wait_for_publisher() {
  local url=$1
  for ((i=1; i<=PUBLISHER_RETRIES; i++)); do
    local code
    code=$(publisher_health "$url")
    if [[ $code == "200" ]]; then
      log "Shared publisher ready (${url})"
      return 0
    fi
    sleep "$RPC_DELAY"
  done
  err "Timed out waiting for shared publisher health at ${url}"
  return 1
}

blockscout_health() {
  local base=$1
  local health="${base%/}/api/health"
  curl --silent --show-error --output /dev/null --write-out '%{http_code}' \
    --max-time "$BLOCKSCOUT_HEALTH_TIMEOUT" --connect-timeout "$BLOCKSCOUT_HEALTH_TIMEOUT" "$health" 2>/dev/null || true
}

wait_for_blockscout() {
  local base=$1
  local display="${base%/}/api/health"
  for ((i=1; i<=BLOCKSCOUT_RETRIES; i++)); do
    local code
    code=$(blockscout_health "$base")
    if [[ $code == "200" ]]; then
      log "Blockscout ready (${base})"
      return 0
    fi
    sleep "$RPC_DELAY"
  done
  err "Timed out waiting for Blockscout health at ${display}"
  return 1
}

service_status_map() {
  compose ps --format '{{.Service}}|{{.State}}|{{.Status}}' 2>/dev/null || true
}

print_status() {
  load_env 0
  local rollup_a_url=${ROLLUP_A_RPC_URL:-http://localhost:18545}
  local rollup_b_url=${ROLLUP_B_RPC_URL:-http://localhost:28545}
  local publisher_http_url=${ROLLUP_SHARED_PUBLISHER_HTTP_URL:-http://localhost:18080}
  local publisher_health_url=${ROLLUP_SHARED_PUBLISHER_HEALTH_URL:-http://localhost:18081/health}
  local delim=$TABLE_DELIM

  declare -A STATES
  while IFS='|' read -r svc state status; do
    [[ -z $svc ]] && continue
    STATES[$svc]="$state|$status"
  done < <(service_status_map)
  local block_a="-"
  if block_a=$(fetch_block_number "$rollup_a_url"); then
    :
  else
    block_a="(no response)"
  fi

  local block_b="-"
  if block_b=$(fetch_block_number "$rollup_b_url"); then
    :
  else
    block_b="(no response)"
  fi

  local pub_code
  pub_code=$(publisher_health "$publisher_health_url")
  if [[ -z $pub_code ]]; then
    pub_code="(no response)"
  fi

  local publisher_entry
  publisher_entry=$(get_service_entry "rollup-shared-publisher" "missing")
  local publisher_state=${publisher_entry%%|*}
  local publisher_status=${publisher_entry#*|}
  local publisher_status_text
  publisher_status_text=$(format_status_text "$publisher_state" "$publisher_status")
  local health_label
  if [[ $pub_code == "200" ]]; then
    health_label="❤️ healthy"
  else
    health_label="⚠️ health $pub_code"
  fi
  local publisher_rows=("$publisher_status_text${delim}$health_label${delim}$publisher_http_url")
  render_panel "rollup-shared-publisher" "${publisher_rows[@]}"
  printf '\n'

  local blockscout_a_base=${BLOCKSCOUT_A_URL:-http://localhost:19000}
  local blockscout_b_base=${BLOCKSCOUT_B_URL:-http://localhost:29000}

  local blockscout_a_entry
  blockscout_a_entry=$(get_service_entry "blockscout-a-proxy" "missing")
  local blockscout_a_state=${blockscout_a_entry%%|*}
  local blockscout_a_status=${blockscout_a_entry#*|}
  local blockscout_a_status_text
  blockscout_a_status_text=$(format_status_text "$blockscout_a_state" "$blockscout_a_status")
  local blockscout_a_code
  blockscout_a_code=$(blockscout_health "$blockscout_a_base")
  [[ -z $blockscout_a_code ]] && blockscout_a_code="(no response)"
  local blockscout_a_health
  if [[ $blockscout_a_code == "200" ]]; then
    blockscout_a_health="❤️ healthy"
  else
    blockscout_a_health="⚠️ health $blockscout_a_code"
  fi

  local blockscout_b_entry
  blockscout_b_entry=$(get_service_entry "blockscout-b-proxy" "missing")
  local blockscout_b_state=${blockscout_b_entry%%|*}
  local blockscout_b_status=${blockscout_b_entry#*|}
  local blockscout_b_status_text
  blockscout_b_status_text=$(format_status_text "$blockscout_b_state" "$blockscout_b_status")
  local blockscout_b_code
  blockscout_b_code=$(blockscout_health "$blockscout_b_base")
  [[ -z $blockscout_b_code ]] && blockscout_b_code="(no response)"
  local blockscout_b_health
  if [[ $blockscout_b_code == "200" ]]; then
    blockscout_b_health="❤️ healthy"
  else
    blockscout_b_health="⚠️ health $blockscout_b_code"
  fi

  local block_label_a
  if [[ $block_a =~ ^[0-9]+$ ]]; then
    block_label_a="⛏️ block $block_a"
  else
    block_label_a="⚠️ block $block_a"
  fi
  local block_label_b
  if [[ $block_b =~ ^[0-9]+$ ]]; then
    block_label_b="⛏️ block $block_b"
  else
    block_label_b="⚠️ block $block_b"
  fi

  local rollup_a_rows=()
  rollup_a_rows+=("op-geth${delim}$(format_service_status "op-geth-a" "missing")${delim}$block_label_a${delim}rpc $rollup_a_url")
  rollup_a_rows+=("op-node${delim}$(format_service_status "op-node-a" "missing")${delim}${delim}rpc http://localhost:19545")
  rollup_a_rows+=("batcher${delim}$(format_service_status "op-batcher-a" "missing")${delim}${delim}port 18548")
  rollup_a_rows+=("proposer${delim}$(format_service_status "op-proposer-a" "missing")${delim}${delim}port 18560")
  rollup_a_rows+=("blockscout${delim}$blockscout_a_status_text${delim}$blockscout_a_health${delim}${blockscout_a_base%/}")
  render_panel "rollup-a (${ROLLUP_A_CHAIN_ID:-?})" "${rollup_a_rows[@]}"
  printf '\n'

  local rollup_b_rows=()
  rollup_b_rows+=("op-geth${delim}$(format_service_status "op-geth-b" "missing")${delim}$block_label_b${delim}rpc $rollup_b_url")
  rollup_b_rows+=("op-node${delim}$(format_service_status "op-node-b" "missing")${delim}${delim}rpc http://localhost:29545")
  rollup_b_rows+=("batcher${delim}$(format_service_status "op-batcher-b" "missing")${delim}${delim}port 28548")
  rollup_b_rows+=("proposer${delim}$(format_service_status "op-proposer-b" "missing")${delim}${delim}port 28560")
  rollup_b_rows+=("blockscout${delim}$blockscout_b_status_text${delim}$blockscout_b_health${delim}${blockscout_b_base%/}")
  render_panel "rollup-b (${ROLLUP_B_CHAIN_ID:-?})" "${rollup_b_rows[@]}"
  printf '\n'

  load_contracts
  if (( ${#CONTRACTS[@]} > 0 )); then
    local contract_rows=()
    local keys=(Mailbox Bridge PingPong MyToken Coordinator)
    local key
    for key in "${keys[@]}"; do
      local value=${CONTRACTS[$key]:-}
      [[ -n $value ]] && contract_rows+=("$key${delim}$value")
    done
    if (( ${#contract_rows[@]} > 0 )); then
      render_panel "CONTRACTS" "${contract_rows[@]}"
      printf '\n'
    fi
  fi
}

cmd_up() {
  load_env 1
  log_source_contexts all
  local running
  running=$(running_services)
  if [[ -n $running ]]; then
    log "Stack already running"
    return 0
  fi

  local existing
  existing=$(existing_services)
  if [[ -n $existing ]]; then
    log "Starting existing containers"
    compose up -d
    return 0
  fi

  if ! is_bootstrapped; then
    log "First run detected; executing scripts/setup.sh"
    (cd "$ROOT_DIR" && ./scripts/setup.sh)
    return 0
  fi

  log "Bringing stack up"
  compose up -d
}

cmd_down() {
  log "Stopping containers"
  compose down || true
}

cmd_purge() {
  local force=0
  if [[ ${1:-} == "--force" || ${1:-} == "-f" ]]; then
    force=1
    shift || true
  fi
  if [[ $force -ne 1 ]]; then
    read -r -p "This will remove containers, volumes, and generated artifacts. Continue? [y/N] " answer
    if [[ ! $answer =~ ^[Yy]$ ]]; then
      log "Aborted"
      return 0
    fi
  fi
  if [[ -f "$ROOT_DIR/networks/rollup-a/runtime.env" || -f "$ROOT_DIR/networks/rollup-b/runtime.env" ]]; then
    log "Stopping and removing containers/volumes"
    compose down -v || true
  else
    log "Skipping compose down (no rollup artifacts present)"
  fi
  log "Removing generated artifacts"
  remove_generated_artifacts
  log "Purge complete"
}

service_targets() {
  local target=$1
  case "$target" in
    op-geth)
      printf '%s\n' "op-geth-a" "op-geth-b" "op-node-a" "op-node-b" "op-batcher-a" "op-batcher-b" "op-proposer-a" "op-proposer-b"
      ;;
    publisher)
      printf '%s\n' "rollup-shared-publisher"
      ;;
    blockscout)
      printf '%s\n' "blockscout-a" "blockscout-b" "blockscout-a-db" "blockscout-b-db" "blockscout-a-redis" "blockscout-b-redis" "blockscout-a-frontend" "blockscout-b-frontend" "blockscout-a-proxy" "blockscout-b-proxy"
      ;;
    all)
      printf '%s\n' \
        "rollup-shared-publisher" \
        "op-geth-a" "op-geth-b" \
        "op-node-a" "op-node-b" \
        "op-batcher-a" "op-batcher-b" \
        "op-proposer-a" "op-proposer-b" \
        "blockscout-a" "blockscout-b" \
        "blockscout-a-db" "blockscout-b-db" \
        "blockscout-a-redis" "blockscout-b-redis" \
        "blockscout-a-frontend" "blockscout-b-frontend" \
        "blockscout-a-proxy" "blockscout-b-proxy"
      ;;
    *)
      err "Unknown target: ${target} (expected op-geth, publisher, blockscout, or all)"
      exit 1
      ;;
  esac
}

build_targets() {
  local target=$1
  case "$target" in
    op-geth)
      printf '%s\n' "op-geth-a" "op-geth-b"
      ;;
    publisher)
      printf '%s\n' "rollup-shared-publisher"
      ;;
    blockscout)
      :
      ;;
    all)
      printf '%s\n' "rollup-shared-publisher" "op-geth-a" "op-geth-b"
      ;;
  esac
}

restart_services() {
  local target=${1:-all}
  load_env 1
  local -a services
  mapfile -t services < <(service_targets "$target")
  if ((${#services[@]} == 0)); then
    err "No services resolved for target ${target}"
    exit 1
  fi
  log "Restarting target ${target}: ${services[*]}"
  if ! compose restart "${services[@]}" >/dev/null 2>&1; then
    compose up -d "${services[@]}"
  else
    compose up -d "${services[@]}" >/dev/null
  fi
  case "$target" in
    op-geth|all)
      wait_for_rpc "${ROLLUP_A_RPC_URL:-http://localhost:18545}" "rollup-a"
      wait_for_rpc "${ROLLUP_B_RPC_URL:-http://localhost:28545}" "rollup-b"
      ;;
  esac
  case "$target" in
    publisher|all)
      wait_for_publisher "${ROLLUP_SHARED_PUBLISHER_HEALTH_URL:-http://localhost:18081/health}"
      ;;
  esac
  case "$target" in
    blockscout|all)
      wait_for_blockscout "${BLOCKSCOUT_A_URL:-http://localhost:19000}"
      wait_for_blockscout "${BLOCKSCOUT_B_URL:-http://localhost:29000}"
      ;;
  esac
}

log_targets() {
  local token=$1

  # Special cases: 'all' and 'publisher'
  case "$token" in
    all)
      printf '%s\n' \
        "rollup-shared-publisher" \
        "op-geth-a" "op-geth-b" \
        "op-node-a" "op-node-b" \
        "op-batcher-a" "op-batcher-b" \
        "op-proposer-a" "op-proposer-b" \
        "blockscout-a" "blockscout-a-db" "blockscout-a-redis" \
        "blockscout-a-frontend" "blockscout-a-proxy" \
        "blockscout-b" "blockscout-b-db" "blockscout-b-redis" \
        "blockscout-b-frontend" "blockscout-b-proxy"
      return
      ;;
    publisher)
      printf '%s\n' "rollup-shared-publisher"
      return
      ;;
    '')
      return 1
      ;;
  esac

  # Service names (both rollups) - for consistency with deploy/restart commands
  case "$token" in
    op-geth)
      printf '%s\n' "op-geth-a" "op-geth-b"
      return
      ;;
    op-node)
      printf '%s\n' "op-node-a" "op-node-b"
      return
      ;;
    op-batcher)
      printf '%s\n' "op-batcher-a" "op-batcher-b"
      return
      ;;
    op-proposer)
      printf '%s\n' "op-proposer-a" "op-proposer-b"
      return
      ;;
    blockscout)
      printf '%s\n' \
        "blockscout-a" "blockscout-a-db" "blockscout-a-redis" \
        "blockscout-a-frontend" "blockscout-a-proxy" \
        "blockscout-b" "blockscout-b-db" "blockscout-b-redis" \
        "blockscout-b-frontend" "blockscout-b-proxy"
      return
      ;;
  esac

  # Handle rollup-specific syntax
  # Support both "a" and "a/" for all services
  if [[ "$token" == "a" || "$token" == "a/" ]]; then
    printf '%s\n' \
      "op-geth-a" "op-node-a" "op-batcher-a" "op-proposer-a" \
      "blockscout-a" "blockscout-a-db" "blockscout-a-redis" \
      "blockscout-a-frontend" "blockscout-a-proxy"
    return
  elif [[ "$token" == "b" || "$token" == "b/" ]]; then
    printf '%s\n' \
      "op-geth-b" "op-node-b" "op-batcher-b" "op-proposer-b" \
      "blockscout-b" "blockscout-b-db" "blockscout-b-redis" \
      "blockscout-b-frontend" "blockscout-b-proxy"
    return
  fi

  # Handle specific service syntax (a/service or b/service)
  if [[ "$token" == "a/"* ]]; then
    local service="${token#a/}"
    case "$service" in
      op-geth)
        printf '%s\n' "op-geth-a"
        ;;
      op-node)
        printf '%s\n' "op-node-a"
        ;;
      op-batcher)
        printf '%s\n' "op-batcher-a"
        ;;
      op-proposer)
        printf '%s\n' "op-proposer-a"
        ;;
      blockscout)
        printf '%s\n' \
          "blockscout-a" "blockscout-a-db" \
          "blockscout-a-redis" "blockscout-a-frontend" \
          "blockscout-a-proxy"
        ;;
      *)
        err "Unknown service: ${service}. Valid services: op-geth, op-node, op-batcher, op-proposer, blockscout"
        exit 1
        ;;
    esac
    return
  elif [[ "$token" == "b/"* ]]; then
    local service="${token#b/}"
    case "$service" in
      op-geth)
        printf '%s\n' "op-geth-b"
        ;;
      op-node)
        printf '%s\n' "op-node-b"
        ;;
      op-batcher)
        printf '%s\n' "op-batcher-b"
        ;;
      op-proposer)
        printf '%s\n' "op-proposer-b"
        ;;
      blockscout)
        printf '%s\n' \
          "blockscout-b" "blockscout-b-db" \
          "blockscout-b-redis" "blockscout-b-frontend" \
          "blockscout-b-proxy"
        ;;
      *)
        err "Unknown service: ${service}. Valid services: op-geth, op-node, op-batcher, op-proposer, blockscout"
        exit 1
        ;;
    esac
    return
  fi

  # Invalid syntax
  err "Invalid log target: ${token}"
  err "Valid targets: all, publisher, a, b, a/<service>, b/<service>"
  err "Valid services: op-geth, op-node, op-batcher, op-proposer, blockscout"
  exit 1
}

cmd_logs() {
  shift || true
  local -a services=()
  local -a options=()
  local accept_options=1
  local expect_value=0
  local pending_option=''
  local arg
  while (($#)); do
    arg=$1
    shift
    if [[ $accept_options -eq 1 && $arg == "--" ]]; then
      accept_options=0
      continue
    fi
    if [[ $accept_options -eq 1 && $expect_value -eq 1 ]]; then
      options+=("$arg")
      expect_value=0
      pending_option=''
      continue
    fi
    if [[ $accept_options -eq 1 && $arg == -* ]]; then
      options+=("$arg")
      case "$arg" in
        --tail|--since)
          expect_value=1
          pending_option="$arg"
          ;;
      esac
    else
      local resolved
      resolved=$(log_targets "$arg")
      local svc
      while IFS=$'\n' read -r svc; do
        [[ -z $svc ]] && continue
        local exists=0
        local current
        for current in "${services[@]}"; do
          if [[ $current == "$svc" ]]; then
            exists=1
            break
          fi
        done
        (( exists == 0 )) && services+=("$svc")
      done <<< "$resolved"
    fi
  done

  if [[ $expect_value -eq 1 ]]; then
    err "Missing value for option: ${pending_option}"
    exit 1
  fi

  if ((${#services[@]} == 0)); then
    local resolved_all
    resolved_all=$(log_targets all)
    while IFS=$'\n' read -r svc; do
      [[ -z $svc ]] && continue
      services+=("$svc")
    done <<< "$resolved_all"
  fi

  log "Streaming logs for: ${services[*]}"
  compose logs "${options[@]}" "${services[@]}"
}

deploy_services() {
  local target=${1:-all}
  load_env 1
  log_source_contexts "$target"
  local -a builds
  mapfile -t builds < <(build_targets "$target")
  if ((${#builds[@]} > 0)); then
    log "Rebuilding images: ${builds[*]}"
    compose build "${builds[@]}"
  fi
  restart_services "$target"
}

main() {
  local cmd=${1:-help}
  case "$cmd" in
    up)
      shift || true
      cmd_up "$@"
      ;;
    down)
      shift || true
      cmd_down "$@"
      ;;
    status)
      shift || true
      print_status "$@"
      ;;
    restart)
      shift || true
      restart_services "${1:-all}"
      ;;
    deploy)
      shift || true
      deploy_services "${1:-all}"
      ;;
    logs)
      cmd_logs "$@"
      ;;
    purge)
      shift || true
      cmd_purge "$@"
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      err "Unknown command: $cmd"
      usage
      exit 1
      ;;
  esac
}

main "$@"
